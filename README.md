# nightsun

Nightsun is a fast, modular fuzzy picker designed to simplify desktop searches for items like browser tabs, tmux sessions, and project directories. It aims to replicate the functionality of Neovim's Telescope or VSCode's command palette, facilitating quick access and switching between tasks without excessive keyboard shortcuts.

## Installation Instructions

<details>
<summary>NixOS Users</summary>

1. **Clone the Repository**: First, clone the repository to your local machine.
2. **Install**: Use the command `nix profile install .` to install the software into your profile.

</details>

<details>
<summary>Other Systems</summary>

1. **Download the Binary**: Visit the releases page and download the latest binary.
2. **Add to Path**: Move the downloaded binary to a directory within your path, or add its directory to your path for easy access.

</details>
 

## Creating and Compiling Custom Modules for Nightsun

Creating custom modules for Nightsun allows you to tailor its functionality to your specific needs, enhancing your desktop environment for productivity. Modules in Nightsun are compiled to Bash functions, enabling seamless integration and the ability to call other modules by name. This guide will walk you through creating a custom module, including the use of aliases to abstract differences between similar functionalities (e.g., different window managers).

### Step 1: Understand Module Components

- **Name**: The unique identifier for your module.
- **Description** (`desc`): A brief overview of what your module does.
- **Prefix**: An optional text that prefixes the items generated by your module.
- **Producer**: A command or script that generates a list of selectable items.
- **Consumer**: The action to perform with the selected item. This is compiled into a Bash function.
- **Alias**: Specifies another module's name to use its functionality, abstracting differences between similar modules.

### Step 2: Define the Producer

Identify how to generate the list of items your module will work with. This step is crucial for guiding the user's selection process. For example, use `ls` to list files in a directory or `git branch` to list all branches in a git repository.

### Step 3: Design the Consumer

This is the action your module will perform on the user's selected item. The consumer is compiled into a Bash function, allowing it to perform complex actions or even call other modules by name. Ensure your consumer command or script accurately manipulates the selected item as intended.

### Step 4: Utilize Aliases for Flexibility

Aliases allow your module to call the functionality of another module, offering flexibility and abstraction. For instance, if your module needs to focus on a window but should work across different window managers, you can alias it to specific modules designed for each window manager (`i3`, `hyprland`, etc.), abstracting the window manager's complexity from the user.

### Step 5: Write Your Module

Combine the components above into your module definition. Here's a simplified template:

```yaml
- name: my_custom_module
  desc: "A brief description of what the module does."
  prefix: "Optional prefix"
  producer: "Command to produce a list of items"
  consumer: |
    "Command or script to act on the selected item."
  alias: "Optional: Name of another module to alias this module to."
```
